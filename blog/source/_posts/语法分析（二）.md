---
title: 语法分析（二）
date: 2020-06-16 10:40:26
tags: 编译原理
categories: 编译原理
---

# 问题

上一节课遇到到了一些问题，比如如何消除左递归，如何确保正确的优先级和结合性。所以本节课的主要目的就是解决这几个问题。

首先温习几个概念，左递归(Left Recursive)、优先级(Priority)和结合性（Associativity）。

在二元表达式的语法规则中，如果产生式的第一个元素是它自身，那么程序就会无限地递归下去，这种情况就叫做**左递归**。比如加法表达式的产生式“加法表达式 + 乘法表达式”，就是左递归的。

我们要想深入探讨语法规则设计，需要像在词法分析环节一样，先了解如何用形式化的方法表达语法规则。

## 书写语法规则，并进行推导

我们已经知道，语法规则是由上下文无关文法表示的，而上下文无关文法是由一组替换规则（又叫产生式）组成的，比如算术表达式的文法规则可以表达成下面这种形式：

```java
add -> mul | add + mul
mul -> pri | mul * pri
pri -> Id | Num | (add) 
```

按照上面的产生式，add 可以替换成 mul，或者 add + mul。这样的替换过程又叫做“推导”。以“2+3*5” 和 “2+3+4”这两个算术表达式为例，这两个算术表达式的推导过程分别如下图所示：![ast树](https://fz-cs.101.com/v0.1/download?dentryId=ef100ffe-f71e-4453-98a4-bfa3a0e42953&size=480&ext=jpg&token=im_disk:BKG5OJg63T7xFIm5xJvb:ws7phnhx40-apGfGCm8OQi-r2c0&expireAt=1592373966776&policy=eyJkZW50cnlJZCI6ImVmMTAwZmZlLWY3MWUtNDQ1My05OGE0LWJmYTNhMGU0Mjk1MyIsInVpZCI6ODcxMDMwLCJyb2xlIjoidXNlciIsInBvbGljeVR5cGUiOiJkb3dubG9hZCJ9)

通过上图的推导过程，你可以清楚地看到这两个表达式是怎样生成的。而分析过程中形成的这棵树，其实就是 AST。只不过我们手写的算法在生成 AST 的时候，通常会做一些简化，省略掉中间一些不必要的节点。比如，“add-add-mul-pri-Num”这一条分支，实际手写时会被简化成“add-Num”。其实，简化 AST 也是优化编译过程的一种手段，如果不做简化，呈现的效果就是上图的样子。

那么，上图中两颗树的叶子节点有哪些呢？Num、+ 和 * 都是**终结符**，**终结符**都是词法分析中产生的 Token。而那些非叶子节点，就是**非终结符**。文法的推导过程，就是把非终结符不断替换的过程，让最后的结果没有非终结符，只有终结符。

**上下文无关文法**就是说这个文法中所有的产生式左边只有一个非终结符，比如：

S -> aSb

S -> ab

这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。

比如：
aSb -> aaSbb
S -> ab

这就是上下文相关文法，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法。

## 上下文文法相关无关扩展

题主的主要疑惑应该在于：什么是上下文，上下文在哪里？为什么说这个文法上下文无关？

答案就是：在应用一个产生式进行推导时，前后已经推导出的部分结果就是上下文。上下文无关的意思的，只要文法的定义里有某个产生式，不管一个非终结符前后的串是什么，就可以应用相应的产生式进行推导。（从形式上来看，就是产生式的左边都是单独一个非终结符，即形如 S-> ...，而不是非终结符左右还有别的东西，例如 aSb -> ...）



这么描述有点儿抽象，我举一个自然语言的例子：

**上下文无关文法：**

产生式：

Sent -> S V O

S -> 人 | 天

V -> 吃 | 下

O -> 雨 | 雪 | 饭 | 肉

其中英文字母都是非终结符（SVO 分别表示主谓宾），汉字都是终结符。

这个文法可以生成如下句子（共 2*2*4=16 种组合，懒得写全了，简单写 7 种意思意思）：

｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝

可以看到，其中有一些搭配在语义上是不恰当的，例如“天吃肉”。其（最左）推导过程为：

Sent -> SVO -> 天VO -> 天吃O -> 天吃肉

但是上下文无关文法里，因为有“V -> 吃 | 下”这样一条产生式，V 就永远都可以推出“吃”这个词，它并不在乎应用“V -> 吃 | 下”这个产生式进行推导时 V 所在的上下文（在这个例子里，就是”天VO“中 V 左右两边的字符串”天“和”O“）。事实上，在 V 推出“吃”这一步，它的左边是“天”这个词，而”天“和”吃“不搭配，导致最后的句子读起来很奇怪。

那**上下文有关文法**呢？产生式可以定义为（其中前两条产生式仍是上下文无关的，后四条则是上下文有关的）：

Sent -> S V O

S -> 人 | 天

人V -> 人吃

天V -> 天下

下O -> 下雨 | 下雪

吃O -> 吃饭 | 吃肉



可以看到，这里对 V 的推导过程施加了约束：虽然 V 还是能推出”吃“和”下“两个词，但是仅仅当 V 左边是”人“时，才允许它推导出”吃“；而当 V 左边是”天“时，允许它推导出”下“。这样通过上下文的约束，就保证了主谓搭配的一致性。类似地，包含 O 的产生式也约束了动宾搭配的一致性。

这样一来，这个语言包含的句子就只有｛人吃饭，天下雨，人吃肉，天下雪｝这四条，都是语义上合理的。

以”人吃饭“为例，推导过程为：

Sent -> SVO -> 人VO -> 人吃O -> 人吃饭

其中第三步推导是这样的：非终结符 V 的上文是“人”，因此可以应用“人V -> 人吃”这条产生式，得到“人VO -> 人吃O”。第四步也类似。

而在实际应用中，语法规则经常写成下面这种形式：

```java
add ::= mul | add + mul
mul ::= pri | mul * pri
pri ::= Id | Num | (add) 
```

这种写法叫做“巴科斯范式”，简称 BNF。Antlr 和 Yacc 这两个工具都用这种写法。为了简化书写，我有时会在课程中把“::=”简化成一个冒号。你看到的时候，知道是什么意思就可以了。

你有时还会听到一个术语，叫做扩展巴科斯范式 (EBNF)。它跟普通的 BNF 表达式最大的区别，就是里面会用到类似正则表达式的一些写法。比如下面这个规则中运用了 * 号，来表示这个部分可以重复 0 到多次：

```java
add -> mul (+ mul)*
```

其实这种写法跟标准的 BNF 写法是等价的，但是更简洁。为什么是等价的呢？因为一个项多次重复，就等价于通过递归来推导。从这里我们还可以得到一个推论：就是上下文无关文法包含了正则文法，比正则文法能做更多的事情。

## 确保正确的优先级

掌握了语法规则的写法之后，我们来看看如何用语法规则来保证表达式的优先级。刚刚，我们由加法规则推导到乘法规则，这种方式保证了 AST 中的乘法节点一定会在加法节点的下层，也就保证了乘法计算优先于加法计算。

听到这儿，你一定会想到，我们应该把关系运算（>、=、<）放在加法的上层，逻辑运算（and、or）放在关系运算的上层。的确如此，我们试着将它写出来：

```java
exp -> or | or = exp   
or -> and | or || and
and -> equal | and && equal
equal -> rel | equal == rel | equal != rel
rel -> add | rel > add | rel < add | rel >= add | rel <= add
add -> mul | add + mul | add - mul 
mul -> pri | mul * pri | mul / pri 
```

## 结合性

什么是结合性呢？同样优先级的运算符是从左到右计算还是从右到左计算叫做结合性。我们常见的加减乘除等算术运算是左结合的，“.”符号也是左结合的。

对于左结合的运算符，递归项要放在左边；而右结合的运算符，递归项放在右边。

## 消除左递归

我提到过左递归的情况，也指出递归下降算法不能处理左递归。这里我要补充一点，并不是所有的算法都不能处理左递归，对于另外一些算法，左递归是没有问题的，比如 LR 算法。

消除左递归，用一个标准的方法，就能够把左递归文法改写成非左递归的文法。以加法表达式规则为例，原来的文法是“add -> add + mul”，现在我们改写成：

```java
add -> mul add'
add' -> + mul add' | ε
```

文法中，ε（读作 epsilon）是空集的意思。接下来，我们用刚刚改写的规则再次推导一下 “2+3+4”这个表达式，得到了下图中左边的结果：

![](https://fz-cs.101.com/v0.1/download?dentryId=e1c6be69-0378-41f7-b24f-746fe9517a76&size=480&ext=jpg&token=im_disk:BKG5OJg63T7xFIm5xJvb:Vr5xqu3bST2CQvqhBGO5PnIsl0w&expireAt=1592385540484&policy=eyJkZW50cnlJZCI6ImUxYzZiZTY5LTAzNzgtNDFmNy1iMjRmLTc0NmZlOTUxN2E3NiIsInVpZCI6ODcxMDMwLCJyb2xlIjoidXNlciIsInBvbGljeVR5cGUiOiJkb3dubG9hZCJ9)

左边的分析树是推导后的结果。问题是，由于 add’的规则是右递归的，如果用标准的递归下降算法，我们会跟上一讲一样，又会出现运算符结合性的错误。我们期待的 AST 是右边的那棵，它的结合性才是正确的。那么有没有解决办法呢？

答案是有的。我们仔细分析一下上面语法规则的推导过程。只有第一步是按照 add 规则推导，之后都是按照 add’规则推导，一直到结束。

如果用 EBNF 方式表达，也就是允许用 * 号和 + 号表示重复，上面两条规则可以合并成一条：

```java
add -> mul (+ mul)*
```

写成这样有什么好处呢？能够优化我们写算法的思路。对于 (+ mul)* 这部分，我们其实可以写成一个循环，而不是一次次的递归调用。伪代码如下：

```
mul();
while(next token is +){
  mul()
  createAddNode
}
```

我们扩展一下话题。在研究递归函数的时候，有一个概念叫做尾递归，尾递归函数的最后一句是递归地调用自身。

编译程序通常都会把尾递归转化为一个循环语句，使用的原理跟上面的伪代码是一样的。相对于递归调用来说，循环语句对系统资源的开销更低，因此，把尾递归转化为循环语句也是一种编译优化技术。

好了，我们继续左递归的话题。现在我们知道怎么写这种左递归的算法了，大概是下面的样子：

```java
private SimpleASTNode additive(TokenReader tokens) throws Exception {
    SimpleASTNode child1 = multiplicative(tokens);  //应用add规则
    SimpleASTNode node = child1;
    if (child1 != null) {
        while (true) {                              //循环应用add'
            Token token = tokens.peek();
            if (token != null && (token.getType() == TokenType.Plus || token.getType() == TokenType.Minus)) {
                token = tokens.read();              //读出加号
                SimpleASTNode child2 = multiplicative(tokens);  //计算下级节点
                node = new SimpleASTNode(ASTNodeType.Additive, token.getText());
                node.addChild(child1);              //注意，新节点在顶层，保证正确的结合性
                node.addChild(child2);
                child1 = node;
            } else {
                break;
            }
        }
    }
    return node;
}
```

修改完后，再次运行语法分析器分析“2+3+4+5”，会得到正确的 AST：

```java
Programm Calculator
    AdditiveExp +
        AdditiveExp +
            AdditiveExp +
                IntLiteral 2
                IntLiteral 3
            IntLiteral 4
        IntLiteral 5
```

这样，我们就把左递归问题解决了。左递归问题是我们用递归下降算法写语法分析器遇到的最大的一只“拦路虎”。解决这只“拦路虎”以后，你的道路将会越来越平坦。

[完整代码](https://github.com/xuejh/complicationBook/tree/master/04/%E7%BB%83%E4%B9%A0%E4%B8%80)

# 参考

这个是本人学习极客时间课程[《编译原理之美》](http://gk.link/a/10j0x)的笔记记录。详情请参考极客时间[《编译原理之美》](http://gk.link/a/10j0x)课程。

[知乎](https://www.zhihu.com/question/21833944)